# Go 语言函数传值与地址示例 - 执行顺序与地址变化

## 代码
```go
package main

import "fmt"

func changeValue(p int) {
    p = 10
}

func main() {
    var a int = 1
    changeValue(a)
    fmt.Println("a =", a) // 输出 a = 1
}
```

---

## 执行顺序与地址变化

### 1. 初始化变量 `a`

```go
var a int = 1
```

- **变量 `a` 被创建**：
    - 地址：`0x0843A040`
    - 值：`1`

#### 内存图示：

| 地址        | 内容  | 变量      | 值         |
|-------------|-------|-----------|------------|
| `0x0843A040` | `1`   | `a int`  | `a = 1`    |

---

### 2. 调用 `changeValue(a)`

根据函数定义， `p` 一开始被赋为 `0`

```go
changeValue(a)
```

- **函数调用**：`changeValue` 接收 `a` 的值 `1` 作为参数。
- **参数 `p` 被初始化**：
    - 地址：`0x0843A06A`（假设的地址）
    - 值：`1`（传入的 `a` 的值）

#### 内存图示：

| 地址        | 内容  | 变量      | 值         |
|-------------|-------|-----------|------------|
| `0x0843A040` | `1`   | `a int`   | `a = 1`    |
| `0x0843A06A` | `1`   | `p int`   | `p = 1`    |

---

### 3. 修改参数 `p`

```go
p = 10
```

- **修改 `p` 的值为 `10`**：
    - 地址：`0x0843A06A`
    - 值：`10`

  在此时，`p` 的修改仅限于 `changeValue` 函数内部。`a` 的值不变。

#### 内存图示：

| 地址        | 内容  | 变量      | 值         |
|-------------|-------|-----------|------------|
| `0x0843A040` | `1`   | `a int`   | `a = 1`    |
| `0x0843A06A` | `10`  | `p int`   | `p = 10`   |

---

### 4. 打印 `a`

```go
fmt.Println("a =", a)
```

- **打印 `a` 的值**：
    - 地址：`0x0843A040`
    - 值：`1`

  打印结果为 `a = 1`，表明 `a` 的值没有受到 `changeValue` 中对 `p` 的修改影响。

#### 内存图示：

| 地址        | 内容  | 变量      | 值         |
|-------------|-------|-----------|------------|
| `0x0843A040` | `1`   | `a int`   | `a = 1`    |
| `0x0843A06A` | `10`  | `p int`   | `p = 10`   |

---

## 总结

- **地址变化**：
    - `a` 在 `main` 中的地址为 `0x0843A040`，在调用 `changeValue(a)` 时，`a` 的值 `1` 被复制给 `p`，但 `p` 的修改仅限于 `changeValue` 函数内部。
    - `p` 在 `changeValue` 中的地址为 `0x0843A06A`，并被赋值为 `10`，但这不会影响到 `a`。

- **打印结果**：
    - 输出 `a = 1`，说明 `a` 的值没有被 `changeValue` 函数中的修改影响。


# Go指针和Rust引用对比

rust引用：https://github.com/1517005260/rustlings-answer/blob/master/exercises/06_move_semantics/README.md

### 1. **Rust 的引用**（与指针的区别）

- **Rust 引用**：
    - 在 Rust 中，引用 (`&` 和 `&mut`) 本质上是对数据的 **借用**，而不是传统意义上的指针。
    - 引用不包含内存地址的直接操作，它仅仅是对数据的**借用**，且这种借用有严格的规则：
        - **不可变引用**（`&T`）：多个引用可以同时存在，但不能修改数据。
        - **可变引用**（`&mut T`）：一次只能有一个可变引用，且数据在引用的生命周期内不能被同时访问。
    - Rust 中的引用 **不能为 `null`**，编译器会在编译时确保引用的生命周期有效，避免悬挂引用、空引用或数据竞争。

  通过 Rust 的生命周期和所有权机制，引用操作是高度安全的，但它不涉及直接的内存地址操作。Rust 编译器会自动管理内存的生命周期，无需手动进行指针操作。

  **例子**：
  ```rust
  let a = 10;
  let b = &a;  // b 是对 a 的不可变引用
  println!("{}", b);  // 输出：10
  ```

    - 在这个例子中，`b` 并不是指向 `a` 的指针，而是对 `a` 的不可变引用。Rust 编译器会确保 `b` 不会在 `a` 的生命周期结束后被使用。

### 2. **Go 的指针**（与 C 的指针相似）

- **Go 指针**：
    - Go 使用指针（`*` 和 `&`）来引用内存地址。指针是一个内存地址，它可以指向变量的位置，并且可以通过 `*` 来解引用（获取指针指向的值）。
    - Go 中的指针和 C 语言中的指针更为接近，虽然 Go 中的指针不能直接进行算术操作（没有指针运算），但它依然是内存地址的引用，可以通过 `&` 获取变量的地址，并通过 `*` 操作符访问指针指向的内容。
    - Go 中的指针 **可以为 `nil`**，即指针可以没有有效的内存地址，类似 C 语言中的空指针。

  **例子**：
  ```go
  var a int = 10
  var p *int = &a  // p 是指向 a 的指针，即 p 是 16 进制数
  fmt.Println(*p)   // 输出：10
  ```

    - 在这个例子中，`p` 是指向 `a` 的内存地址的指针。通过 `*p` 解引用，可以访问 `a` 的值。

### 3. **C 的指针**（传统指针）

- **C 指针**：
    - C 中的指针是直接操作内存地址。指针变量存储的是内存的地址，并且可以通过指针进行内存操作。
    - C 允许指针算术（即对指针进行加减操作），并且指针可以为 `NULL`，指向无效的内存区域。

  **例子**：
  ```c
  int a = 10;
  int *p = &a;  // p 是指向 a 的指针
  printf("%d\n", *p);  // 输出：10
  ```

    - 在 C 中，`p` 存储的是 `a` 的内存地址，通过 `*p` 解引用，访问 `a` 的值。指针操作更为底层，允许直接对内存进行控制。

### 总结：

- **Rust 的引用**（`&` 和 `&mut`）并不等同于传统的指针，它们是对数据的**借用**，是 Rust 为了保证内存安全和避免数据竞争而设计的机制。引用不直接操作内存地址，而是通过生命周期管理确保引用的合法性。

- **Go 的指针**（`*` 和 `&`）类似于传统的 C 指针，指向内存地址。通过指针，可以访问和修改存储在该地址的数据，指针可以为 `nil`，并且 Go 采用垃圾回收机制来管理内存。

- **C 的指针** 是最接近低级语言中的指针概念，直接操作内存地址并支持指针算术操作，指针为 `NULL` 时可能导致空指针异常。

因此，**Rust 的引用并不等同于指针**，而是更高层次的概念，强调内存安全和生命周期的管理。相比之下，**Go 和 C 中的指针**更直接地涉及到内存地址的操作。